# RFC 9112 §2 — Message

## RFC 9112 §2.1 — Message Format

```
  HTTP-message   = start-line CRLF
                    *( field-line CRLF )
                    CRLF
                    [ message-body ]
```

```
  start-line     = request-line / status-line
```

## RFC 9112 §2.2 — Message Parsing

#### Line termination & illegal bytes
- A recipient MAY treat a single LF (`0x0A`) as a line terminator for the start-line and header fields (ignore any preceding CR).
- Senders MUST NOT generate a bare CR (`0x0D`) outside the content.

#### Extra CRLFs around requests
- Some HTTP/1.0 user agents may send an extra `CRLF` after a POST body.
- HTTP/1.1 user agents MUST NOT preface or follow a request with an extra `CRLF`. If `CRLF` is used to terminate a body, it counts toward the body length.

#### Whitespace between start-line and headers
- A sender MUST NOT send any whitespace between the start-line and the first header field.

## RFC 9112 §2.3 — HTTP Version

```
  HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
  HTTP-name     = %s"HTTP"
```

---

###### Practical notes for implementation
- “Recipient” includes servers, clients, and intermediaries—apply the rules wherever you parse.
- Tolerance for single `LF` applies to start-line/headers only. **Do not** relax CRLF requirements in chunked transfer-coding or other body framing.

# RFC 9112 §3 - Request Line

## RFC 9112 §3.1 — Method
- `request-line = method SP request-target SP HTTP-version`  
  **[Severity: MUST]** (single `SP` between components)

- Lenient separators: recipients **MAY** parse on whitespace-delimited boundaries and treat `SP | HTAB | VT | FF | bare CR` as the `SP` separators (ignoring leading/trailing whitespace).  
  **[Severity: MAY]** → WAF: accept but **FLAG**.

## RFC 9112 §3.2 — Request Target

```
  request-target = origin-form
                 / absolute-form
                 / authority-form
                 / asterisk-form
```

- **Whitespace existance** No whitespace is allowed in the request-target
  **[Severity: MUST NOT]** → WAF: flag if present. 

- **Host field presence:** A client **MUST** send a `Host` header field in **all** HTTP/1.1 requests.  
  **[Severity: MUST]** → WAF: flag if missing. 

- **Exact authority match:** If the target URI includes an **authority** component, `Host` **MUST** be **identical** to that authority (excluding any `userinfo` and its "`@`").  
  **[Severity: MUST]** → WAF: flag if `Host` ≠ authority (host and, if present, port must match exactly). 

- **No authority in target URI:** If the target URI’s authority is **missing or undefined**, the client **MUST** send a `Host` header with an **empty** field value.  
  **[Severity: MUST]** → WAF: flag if non-empty. 

## Per request-target form (RFC 9112 §3.2)
- **origin-form** (`absolute-path [ "?" query ]`): client sends only path+query in the request line; `Host` is still required per 7.2.  
  **[Severity: MUST]** → WAF: ensure `Host` present (non-empty) and consistent with the intended authority. 

- **absolute-form** (`absolute-URI`): typically used to a proxy.  
  **[Severity: MUST]** → WAF: require `Host` present and **identical** to the authority in the absolute-URI; flag mismatch. (Servers that receive absolute-form will ignore `Host` and use the request-target’s authority, but our check is the client-side MUST.) 

- **authority-form** (`uri-host ":" port`, for `CONNECT`): request-target is just `host:port`.  
  **[Severity: MUST]** → WAF: require `Host` present and **identical** to `host:port`. 

- **asterisk-form** (`"*"`, server-wide `OPTIONS`): target URI has **no authority**.  
  **[Severity: MUST]** → WAF: require `Host` present with an **empty** value. 

# RFC 9112 §5 — Field Syntax (WAF flag rules only)

> Scope: header-line syntax; include only conditions that trigger a flag.  
> Policy: keep RFC severity tags (MUST, MUST NOT, etc.).

## Field line shape
- **Header line MUST match** `field-name ":" OWS field-value OWS`.  
  **[Severity: MUST]** → Flag any header line missing the colon delimiter or not starting with a valid `field-name`.

- **No whitespace before the colon.**  
  **[Severity: MUST NOT]** → Flag any `field-name<WS>":"` (space or tab between name and `:`).

## Obsolete line folding
- **obs-fold is forbidden in HTTP/1.1 messages _except_ when the message is packaged as media type `message/http`.**  
  **[Severity: MUST NOT]** → Flag any folded header **unless** you are explicitly parsing a `message/http` container.

# RFC 9112 §6 — Body Framing Headers (WAF flag rules)

> Scope: request headers only; syntax/consistency that signals anomalies.  
> Policy: keep RFC severities; no behavior text.

## Transfer-Encoding / Content-Length interplay
- **Both present** in the same request headers.  
  **[Severity: MUST NOT]** → Flag.

- **HTTP/1.0 request with `Transfer-Encoding` present.**  
  **[Severity: MUST NOT]** → Flag.

## Content-Length validity
- **Invalid `Content-Length` value** (not a valid decimal non-negative integer).  
  **[Severity: MUST]** → Flag.

- **Multiple `Content-Length` values that are not all identical**  
  (e.g., `Content-Length: 10, 11` or multiple header lines with differing values).  
  **[Severity: MUST]** → Flag.

## Transfer-Encoding value (requests)
- `Transfer-Encoding` present **and `chunked` is not the final coding** in the value list.  
  **[Severity: MUST]** → Flag.

# RFC 9112 §7 — Transfer Codings

## RFC 9112 §7.1 — Chunked Transfer Coding
- Each chunk header line and each chunk data line **MUST** end with `CRLF`. Flag bare `LF` or missing `CRLF`. **[Severity: MUST]**
- `chunk-size` **MUST** be a non-empty sequence of hexadecimal digits (`1*HEXDIG`). Any other characters → invalid. **[Severity: MUST]**
- The terminating “last chunk” line **MUST** be one or more `0` digits (optionally with chunk extensions), then `CRLF`. Non-zero last chunk or missing terminator → invalid. **[Severity: MUST]**
- The overall `chunked-body` **MUST** end with an extra `CRLF` after the (optional) trailer section. Missing final `CRLF` → invalid. **[Severity: MUST]**
- The `chunked` transfer coding defines **no parameters**; if `Transfer-Encoding` contains `chunked;...` treat as an error. **[Severity: SHOULD]**
- Applying `chunked` more than once (e.g., `Transfer-Encoding: chunked, chunked`) is forbidden. **[Severity: MUST NOT]**

## RFC 9112 §7.1.1 — Chunk Extensions
- Extension grammar: after `chunk-size`, zero or more `;`-separated params.
  - `chunk-ext-name` **MUST** be a `token`. **[Severity: MUST]**
  - `chunk-ext-val` **MUST** be a `token` or a `quoted-string`. **[Severity: MUST]**
- Malformed names/values (CTLs, bad quotes, illegal bytes) → flag. **[Severity: MUST]**

## RFC 9112 §7.1.2 — Chunked Trailer Section
- Trailer section lines **MUST** be valid HTTP `field-line`s and each **MUST** end with `CRLF`. **[Severity: MUST]**
- After the (possibly empty) trailer section there **MUST** be a final empty line (`CRLF`). **[Severity: MUST]**

## RFC 9112 §7.1.3 — Decoding Chunked
- For each chunk: read `chunk-size` line (`CRLF`), then read exactly `chunk-size` octets of data followed by `CRLF`. Size mismatch or missing `CRLF` → invalid. **[Severity: MUST]**

## RFC 9112 §7.2 — Transfer Codings for Compression
- `compress`/`x-compress`, `deflate`, `gzip`/`x-gzip` **define no parameters**; if used as `Transfer-Encoding` with parameters (e.g., `gzip;level=9`) treat as an error. **[Severity: SHOULD]**

## RFC 9112 §7.3 — Transfer Coding Registry
- (No directly checkable wire-syntax rules for a WAF beyond recognizing that coding names are case-insensitive and typically registered; skip flagging here.)

## RFC 9112 §7.4 — Negotiating Transfer Codings (TE)
- `TE` header **MUST NOT** list `chunked`. Flag `TE: chunked`. **[Severity: MUST NOT]**
- If a message includes a `TE` header, the `Connection` header **MUST** include the token `TE` (hop-by-hop scoping). Missing `Connection: TE` when `TE` is present → flag. **[Severity: MUST]**

# RFC 9112 §8 — Handling Incomplete Messages

> Scope: syntax-only conditions that indicate an **incomplete** HTTP/1.1 message.  
> Policy: list only what your WAF should **flag**.

- **Header section incomplete** — connection closes before the empty line (no `CRLF` after the last header line).  
  **[Classification: INCOMPLETE]** → Flag.

- **Chunked body incomplete** — message uses `Transfer-Encoding: chunked` but the terminating zero-size chunk (`0\r\n`) (and final `\r\n`) is not present.  
  **[Classification: INCOMPLETE]** → Flag.

- **Content-Length short read** — message uses a valid `Content-Length` but the received body octets are **fewer** than the declared length.  
  **[Classification: INCOMPLETE]** → Flag.

- **Close-delimited response mid-headers** — response without `Content-Length` and not chunked terminates by connection close; if the close occurs **during the header section**, treat as incomplete.  
  **[Classification: INCOMPLETE]** → Flag.

# RFC 9112 §10 — Enclosing Messages as Data

## RFC 9112 §10.1 — Media Type message/http
- **Body MUST contain exactly one HTTP message (request or response).**  
  **[Severity: MUST]** → Flag if the enclosed body is not a single, syntactically valid HTTP start-line + header section (+ optional body).

## RFC 9112 §10.2 — Media Type application/http
- **Messages in the body MUST NOT be intermixed (all requests or all responses).**  
  **[Severity: MUST NOT]** → Flag if the enclosed pipeline mixes requests and responses.

- **If `msgtype` parameter is present, it MUST be `request` or `response` and MUST match the enclosed messages.**  
  **[Severity: MUST]** → Flag invalid values or mismatch (e.g., `msgtype=request` but body contains responses).

- **If `version` parameter is present, it MUST be a valid HTTP-version and MUST match each enclosed message’s start-line.**  
  **[Severity: MUST]** → Flag invalid syntax (not `DIGIT "." DIGIT`) or mismatch with any enclosed message.

- **Obsolete line folding (obs-fold) is NOT allowed in application/http bodies.**  
  **[Severity: MUST NOT]** → Flag any folded header lines in the enclosed messages.